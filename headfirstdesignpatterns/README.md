## 1.문제가 무엇인가?

---

- 상속을 사용하는 것이 그리 성공적이지 못하다
- Flyable과 Quackable 인터페이스 사용하는 방법들은 처음에는 괜찮아 보이지만
  자바 인터페이스에는 구현된 코드가 전혀 들어가지 않기 때문에 코드 재사용을 할수 없다.
  (자바 8부터는 default 를 이용해서 구현할 수 있다)

## 디자인 원칙
달라지는 부분과 달라지지 않는 부분을 분리 한다.   
상속보다는 구성을 활용한다.  
구현보다 인터페이스에 맞춰서 프로그래밍한다.

## 어떻게 해야할까?
요구사항이 있을 때마다 바뀌는 부분이 있다면 그 행동을 바뀌지 않는 다른 부분으로 골라내서
분리해야 한다는 것을 알 수 있다.

바뀌는 부분은 캡슐화 시킨다. ( 바뀌지 않는 부부넹 영향을 미치지 않아 수정 or 확장에 용이하다)

## 바뀌는 부분과 그렇지 않은 부분 분리 하기

- 아래 부분은  Duck 클래스에서 오리마다 달라지는 부분입니다.  

```java
    public void fly();
    public void quack();
```

-----
## 나는 행동과 꽥꽥거리는 행동을 구현하는 클래스 집합은 어떻게 디자인해야할까요?

--- 
### 이 문제의 시작은 오리의 행동의 변화 때문입니다.

- 이전까지는 Duck에 행동을 구현했지만 이제는 자체로 구현할 수 있더록 설계했습니다. (quackBehavior ,flybehavior)

### 하지만 왜 인터페이스를 이용해야할까요?

- "인터페이스에 맞춰서 프로그래밍한다는" 것은 "상위" 형식에 맞춰서 프로그래밍한다는 것을 의미합니다.
- 반드시 자바의 인터페이스를 사용하는 것이 아니라 실제 실행시에 쓰이는 객체가   
  코드에 의해서 고정되지 않도록, 어떤 상위 형식에 맞춰서 프로그래밍함으로써 '다형성'을 활용해야한다는 것입니다.   
  그렇게 함으로써 좀더 유연할 설계를 할 수있게 됩니다.


## 생각의 전환

1. 바뀔 수 있는 부분을 미리 예측하여 미리대처할 수 있는 유연하 설계를 해야한다.


## 결론 
1. 변화는 영역인 (소리, 날다)는 캡슐화를 통해 별도의 인터페으스로 설계 되었습니다.
2. 각각의 클래스는 연관관계 , 의존관계, 상속관계 ,구현관계로 나눌 수있습니다. 

### 스트래지 패턴
알고리즘을 정의하고 각각 캡슐화 하여 교환해서 사용할 수 있도록 만든다.   
스트래티지을 활용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.

### 활용편 
보험상품을 예를 들어보자 
고객사에서 각각의 상품(상품 제목 , 상품설명, 납입방법)


#2 옵저버 패턴

--- 

##2-1. 요구사항

+ 기상 정보 스테이션을 개발
  + Weather DATA 객체를 바탕으로 개발한다.
    + 기온, 습도, 기압 추적하는 객체이다.
  + 세개의 항목은 각각 현재 조건, 기상 통계, 기상예보를 최신 측정치를 수집할 때 실시간으로 갱신된다.
  + 다른 개발자들이 사용할 수 있도록 API를 만들 예정이다.

+ 정리 
  + 기상데이터를 사용하는 세개의 디스프레이 항목을 구현
    1. 현재조건을 표시
    2. 기상통계를 표시
    3. 기상예보를 표시
    4. WeatherData에서 새로운 측정값이 들어올 때마다 디스플레이스를 갱신해야한다.
    5. 시스템이 확장성이있어야한다.
       + 디스플레이 항목을 추가/제거할 수 있도록 해야한다.
         + 상위 1~3번 기능을 말함

```java

public class WeatherData {
    void getTemperature();  //온도 
    void getHumidity();     //습도
    void getPressure();     //기압

    /**
     * 기상 값이 갱신될 때마다 알려주기 위한 메소드
     * 현재조건, 기상통계, 기상예측
     */
    public void measurementsChanged() {
      float temp = getTemperature();
      float humidity = getHumidity();
      float pressure = getPressure();

      /**
       *  구체적인 구현에 맞춰서 고딩했기 때문에 프로그램을 고치지 않고서는 다른 디스플레이를 추가/삭제할 수 없다.
       *  파라미터는 동일한 인자값을 사용하고 있다는 것을 알 수있다.
       */
      currentConditionDisplay.update(temp, humidity, pressure);
      statisticsDisplay.update(temp, humidity, pressure);
      forecastDisplay.update(temp, humidity, pressure);
    }
} 
```

## 2.2 옵저버 패턴이란? 
 + 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식   
 + **일대 다** 의존성을 정의합니다.
   + 옵저버들은 주제에 의존합니다.
   + 주제의 상태가 바뀌면 옵저버한테 연락이 갑니다. 
   + 연락 방법에 따라 옵저에 있는 값이 새로운 값으로 갱신될 수도 있습니다.
   + subject인터페이스와 옵저 인터페이스가 들어있는 크래스 디자인을 바탕을 설계되어 있습니다.

## 느슨한 결합
  + 두 객체가 느슨하게 결합되어 있다는 것은 그 둘이 상호 작요을 하긴 하지만 서로에 대해 서로 잘 모른다는 것을 의미합니다.
  * 옵저버 : 구상클래스(주체)가 무엇인지 옵저버가 무엇을 하는지 등에 대해서는 알 필요가 없습니다.
  * 옵저버는 언제든지 생로 추가 할수 있습니다.
  * 새로운 형식의 옵저버를 추가하려고 할 때도 주제를 전혀 변경할 필요가 없습니다.
  * 주제와 옵저버는 서로 독립적으로 재사용할 수있습니다.
  * 주제나 옵저버가 바뀌더라도 서로한테 영향을 끼치지 않습니다.

## 자바 API에서 제공하는 옵저버 패턴을 사용해봅시다.
+ 객체가 옵저가 되는 방법 
  + Observer 인터페이스를 구현 
  + Observable 객체의 addObserver() 메소를 호출
+ Observable 에 알리는 방법
  + setChanged 메소드를 호출해서 객체의 상태가 바뀌었다는 것을 알리는 것
  + notifyObbservers(), notifyObservers(Object arg)
+ Observer 연락을 받는 방법 
  ```java
    // 연락을 보내느 주체 객체가 인자로 전달
    /** 
       notifyObservers() 메소드에서 인자로 전달된 데이터 객체, 
       데이터 객체가 지정되지 않느 경우 Null이다. 
    */
    update(Observable o ,Object arg)
  ```
### setChanged는 무엇인가? 
+ 상태가 변경되었다는 것을 밝히기 위한 용도로 사용된다.
+ notifyObservers() 메소드가 호출 되었을 때 setChanged가 호출되지 않은상태에서 notifyObservers()가 호출되면   
  옵저버들에게 아무런 연락을 하지 않습니다. 이러한 용도로 조건에 따라서 사용할 수 있도록 필요한 메소드입니다.

### 자바 API Observable의 단점
+ Observable은 인터페이스가 아닌 클래스인 데다가, 어떤 인터페이스를 구현하는 것도 아닙니다.   
  구현에 있어서 제약 조건으로 작용하는 몇 가지 문제점이 있습니다.
+ Observable이 클래스기 때문에 서브클래스를 만들어야한다는 점이 문제가 된다.
+ Observable에 기능을 추가할 수 없으며 핵심 메소드를 외부에서 호출할 수없습니다.

### 주의할점 
옵저버 패턴은 순서가 바뀐다고 해서 다른 결과가 나와서는 안됩니다.   
만약 바뀌게 된다면 이것은 느슨한 결합이라고 할 수 없게 됩니다.