## 1.문제가 무엇인가?

---

- 상속을 사용하는 것이 그리 성공적이지 못하다
- Flyable과 Quackable 인터페이스 사용하는 방법들은 처음에는 괜찮아 보이지만
  자바 인터페이스에는 구현된 코드가 전혀 들어가지 않기 때문에 코드 재사용을 할수 없다.
  (자바 8부터는 default 를 이용해서 구현할 수 있다)

## 디자인 원칙
달라지는 부분과 달라지지 않는 부분을 분리 한다.   
상속보다는 구성을 활용한다.  
구현보다 인터페이스에 맞춰서 프로그래밍한다.

## 어떻게 해야할까?
요구사항이 있을 때마다 바뀌는 부분이 있다면 그 행동을 바뀌지 않는 다른 부분으로 골라내서
분리해야 한다는 것을 알 수 있다.

바뀌는 부분은 캡슐화 시킨다. ( 바뀌지 않는 부부넹 영향을 미치지 않아 수정 or 확장에 용이하다)

## 바뀌는 부분과 그렇지 않은 부분 분리 하기

- 아래 부분은  Duck 클래스에서 오리마다 달라지는 부분입니다.  

```java
    public void fly();
    public void quack();
```

-----
## 나는 행동과 꽥꽥거리는 행동을 구현하는 클래스 집합은 어떻게 디자인해야할까요?

--- 
### 이 문제의 시작은 오리의 행동의 변화 때문입니다.

- 이전까지는 Duck에 행동을 구현했지만 이제는 자체로 구현할 수 있더록 설계했습니다. (quackBehavior ,flybehavior)

### 하지만 왜 인터페이스를 이용해야할까요?

- "인터페이스에 맞춰서 프로그래밍한다는" 것은 "상위" 형식에 맞춰서 프로그래밍한다는 것을 의미합니다.
- 반드시 자바의 인터페이스를 사용하는 것이 아니라 실제 실행시에 쓰이는 객체가   
  코드에 의해서 고정되지 않도록, 어떤 상위 형식에 맞춰서 프로그래밍함으로써 '다형성'을 활용해야한다는 것입니다.   
  그렇게 함으로써 좀더 유연할 설계를 할 수있게 됩니다.


## 생각의 전환

1. 바뀔 수 있는 부분을 미리 예측하여 미리대처할 수 있는 유연하 설계를 해야한다.


## 결론 
1. 변화는 영역인 (소리, 날다)는 캡슐화를 통해 별도의 인터페으스로 설계 되었습니다.
2. 각각의 클래스는 연관관계 , 의존관계, 상속관계 ,구현관계로 나눌 수있습니다. 

### 스트래지 패턴
알고리즘을 정의하고 각각 캡슐화 하여 교환해서 사용할 수 있도록 만든다.   
스트래티지을 활용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.

### 활용편 
보험상품을 예를 들어보자 
고객사에서 각각의 상품(상품 제목 , 상품설명, 납입방법)


#2 옵저버 패턴

--- 

##2-1. 요구사항

+ 기상 정보 스테이션을 개발
  + Weather DATA 객체를 바탕으로 개발한다.
    + 기온, 습도, 기압 추적하는 객체이다.
  + 세개의 항목은 각각 현재 조건, 기상 통계, 기상예보를 최신 측정치를 수집할 때 실시간으로 갱신된다.
  + 다른 개발자들이 사용할 수 있도록 API를 만들 예정이다.

+ 정리 
  + 기상데이터를 사용하는 세개의 디스프레이 항목을 구현
    1. 현재조건을 표시
    2. 기상통계를 표시
    3. 기상예보를 표시
    4. WeatherData에서 새로운 측정값이 들어올 때마다 디스플레이스를 갱신해야한다.
    5. 시스템이 확장성이있어야한다.
       + 디스플레이 항목을 추가/제거할 수 있도록 해야한다.
         + 상위 1~3번 기능을 말함

```java

public class WeatherData {
    void getTemperature();  //온도 
    void getHumidity();     //습도
    void getPressure();     //기압

    /**
     * 기상 값이 갱신될 때마다 알려주기 위한 메소드
     * 현재조건, 기상통계, 기상예측
     */
    public void measurementsChanged() {
      float temp = getTemperature();
      float humidity = getHumidity();
      float pressure = getPressure();

      /**
       *  구체적인 구현에 맞춰서 고딩했기 때문에 프로그램을 고치지 않고서는 다른 디스플레이를 추가/삭제할 수 없다.
       *  파라미터는 동일한 인자값을 사용하고 있다는 것을 알 수있다.
       */
      currentConditionDisplay.update(temp, humidity, pressure);
      statisticsDisplay.update(temp, humidity, pressure);
      forecastDisplay.update(temp, humidity, pressure);
    }
} 
```

## 2.2 옵저버 패턴이란? 
 + 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식   
 + **일대 다** 의존성을 정의합니다.
   + 옵저버들은 주제에 의존합니다.
   + 주제의 상태가 바뀌면 옵저버한테 연락이 갑니다. 
   + 연락 방법에 따라 옵저에 있는 값이 새로운 값으로 갱신될 수도 있습니다.
   + subject인터페이스와 옵저 인터페이스가 들어있는 크래스 디자인을 바탕을 설계되어 있습니다.

## 느슨한 결합
  + 두 객체가 느슨하게 결합되어 있다는 것은 그 둘이 상호 작요을 하긴 하지만 서로에 대해 서로 잘 모른다는 것을 의미합니다.
  * 옵저버 : 구상클래스(주체)가 무엇인지 옵저버가 무엇을 하는지 등에 대해서는 알 필요가 없습니다.
  * 옵저버는 언제든지 생로 추가 할수 있습니다.
  * 새로운 형식의 옵저버를 추가하려고 할 때도 주제를 전혀 변경할 필요가 없습니다.
  * 주제와 옵저버는 서로 독립적으로 재사용할 수있습니다.
  * 주제나 옵저버가 바뀌더라도 서로한테 영향을 끼치지 않습니다.

## 자바 API에서 제공하는 옵저버 패턴을 사용해봅시다.
+ 객체가 옵저가 되는 방법 
  + Observer 인터페이스를 구현 
  + Observable 객체의 addObserver() 메소를 호출
+ Observable 에 알리는 방법
  + setChanged 메소드를 호출해서 객체의 상태가 바뀌었다는 것을 알리는 것
  + notifyObbservers(), notifyObservers(Object arg)
+ Observer 연락을 받는 방법 
  ```java
    // 연락을 보내느 주체 객체가 인자로 전달
    /** 
       notifyObservers() 메소드에서 인자로 전달된 데이터 객체, 
       데이터 객체가 지정되지 않느 경우 Null이다. 
    */
    update(Observable o ,Object arg)
  ```
### setChanged는 무엇인가? 
+ 상태가 변경되었다는 것을 밝히기 위한 용도로 사용된다.
+ notifyObservers() 메소드가 호출 되었을 때 setChanged가 호출되지 않은상태에서 notifyObservers()가 호출되면   
  옵저버들에게 아무런 연락을 하지 않습니다. 이러한 용도로 조건에 따라서 사용할 수 있도록 필요한 메소드입니다.

### 자바 API Observable의 단점
+ Observable은 인터페이스가 아닌 클래스인 데다가, 어떤 인터페이스를 구현하는 것도 아닙니다.   
  구현에 있어서 제약 조건으로 작용하는 몇 가지 문제점이 있습니다.
+ Observable이 클래스기 때문에 서브클래스를 만들어야한다는 점이 문제가 된다.
+ Observable에 기능을 추가할 수 없으며 핵심 메소드를 외부에서 호출할 수없습니다.

### 주의할점 
옵저버 패턴은 순서가 바뀐다고 해서 다른 결과가 나와서는 안됩니다.   
만약 바뀌게 된다면 이것은 느슨한 결합이라고 할 수 없게 됩니다.

## 디자인 원칙을 적용해서 생각해보자 
 + 애플리케이션에서 바뀌는 부분을 찾아내서 바뀌는 지 않는 부분으로부터 분리한다.
   + 옵저버 패턴에 변하는것은 주제의 상태와 옵저버의 개수,형식 주제를 변경하지 않아도   
   주제의 상태에 의존하는 객체들을 바꿀 수 있습니다.
 + 특정구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
   Subject와 Observer에서 모두 인터페이스를 사용했습니다. Subject에서는 Subject 인터페이스를 통해서 
   Observer 인터페이스를 구현하는 객체들의 등록/탈퇴를 관리하고 그런객체들에게 연락을 돌립니다.
 + 상속보다는 구성을 활용한다.
   + 옵저 패턴에서는 구성을 활용하여 옵저버들을 관리합니다
   + 주제와 옵저버 사이의 관계는 상속이 아니라 구성에 의해서 이루어지죠

## 3. 데코레이터 패턴 

---

### OCP(OPEN-CLOSED PRINCIPLE) 개방폐쇄 원칙
+ 클래스는 확장에는 열려있어야 하지만 코드 변경에 대해서는 닫혀있어야한다.
+ OCP를 적용하는 것은 시간낭비가 될 수도 있고 쓸데없는 일을하는 것일 수도 있습니다.
+ 결과적으로 불 필요하게 복자하고 이해하기 힘든 코드만 만들게 되는 부작용이 될 수 있으니 주의해야합니다.

### 디자인패턴에서 OCP를 준수하려면 어떻게 해야할까요? 
+ 보통은 불가능합니다. 가장 많이 변경될 수 있는 여지가 있는 곳을 디자인패턴을 접목할 생각해봐야합니다.

### 데코레이터 패턴이란 무엇인가? 
> 객체에 추가적인 요건을 동적으로 첨가할 수 있는 패턴이다.
> 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.

+ 수퍼 클래스는 자신이 장식하고 있는 객체의 수퍼클래스와 같습니다.
+ 한 객체를 여러 개의 데코레이터롤 감쌀 수 있습니다.
+ 데코레이터는 자신이 감싸고 있는 객체와 같은 수퍼 클래스를 가지고 있기 때문에 원래 객체가 들어갈 자리에   
데코레이터 객체를 집어 넣어도 상관없습니다. 
> __데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위힘하는 것 외에 원하는 추가적인 작업을 수행할 수 있습니다.__


### 자바 API 데코레이터 패턴을 확인해보자
+ InputStream 데코레이턴의 수퍼클래스가됩니다.
+ FileInputStream , StringBufferInputStream, ByteArrayInputStream은 데코레이터로 포장 될 구상 구성요소 역할을 합니다.
+ FilterInputStream은 추상 데코레이터입니다.
+ PushbackInputStream BuffedInputStream DataInputStream 등이 데코레이터들입니다.


### 실습해봅시다
+ 사이즈 개념을 도입하기로 했습니다.
+ 커피를 이제는 톨, 그란데 벤티 중에서 골라서 주문할 수 있ㅅ브니다.
+ Beverage 클래스에 사이즈의 get/set을 추가했습니다.
+ 사이즈에 따라서 가격도 다르게 받을 계획입니다.

## 만약에 각음료마다 코스트가 달라야한다면 각 클래별로 금액을 설정하는 것이 맞는가? 

# 3. 팩토리 패턴 

--- 
> 팩토리 메소드 패턴   
> 객체를 생성하기 위한 인터페이스를 만듭니다. 
> 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하도록합니다.
> 팩토리 메소드를 이용하면 인스터스를 만드는 일을 서브 클래스로 미룰수 있습니다.

## 요구사항
+ 피자는 여러가지의 종류(불고기피자,양파피자)를 가지고 있습니다.
```java
public Pizza orderPizza(String type) {
    private Pizza pizza;
        if(type.equals) {
            pizza = new CheesePizza();
        }else if (type.equals("greek")) {
            pizza = new GreekPizza();
        }else if (type.equals("pepperoni")) {
            pizza = new PepperoniPizza();
        }
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    return pizza;
}
```
+ 새로운 신제품인 조개피자와 야채피자가 추가되었습니다. 그리고 페퍼로니와 치즈 피자를 제외 시키려고 합니다.
+ 하지만 아래와 같은 방식은 OCP 위배하게 됩니다.
```java
public Pizza orderPizza(String type) {
    private Pizza pizza;
        if (type.equals("clam")) {
            pizza = new ClamPizza();
        }else if (type.equals("veggie")) {
            pizza = new VeggiePizza();
        }
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    return pizza;
}
```
+ 이를 통해 우리가 알 수 있는것은 변화는 부분과 변하지 않는 부분을 구분하는 것입니다.