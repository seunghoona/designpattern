## 1.문제가 무엇인가?

---

- 상속을 사용하는 것이 그리 성공적이지 못하다
- Flyable과 Quackable 인터페이스 사용하는 방법들은 처음에는 괜찮아 보이지만
  자바 인터페이스에는 구현된 코드가 전혀 들어가지 않기 때문에 코드 재사용을 할수 없다.
  (자바 8부터는 default 를 이용해서 구현할 수 있다)

## 디자인 원칙
달라지는 부분과 달라지지 않는 부분을 분리 한다.   
상속보다는 구성을 활용한다.  
구현보다 인터페이스에 맞춰서 프로그래밍한다.

## 어떻게 해야할까?
요구사항이 있을 때마다 바뀌는 부분이 있다면 그 행동을 바뀌지 않는 다른 부분으로 골라내서
분리해야 한다는 것을 알 수 있다.

바뀌는 부분은 캡슐화 시킨다. ( 바뀌지 않는 부부넹 영향을 미치지 않아 수정 or 확장에 용이하다)

## 바뀌는 부분과 그렇지 않은 부분 분리 하기

- 아래 부분은  Duck 클래스에서 오리마다 달라지는 부분입니다.  

```java
    public void fly();
    public void quack();
```

-----
## 나는 행동과 꽥꽥거리는 행동을 구현하는 클래스 집합은 어떻게 디자인해야할까요?

--- 
### 이 문제의 시작은 오리의 행동의 변화 때문입니다.

- 이전까지는 Duck에 행동을 구현했지만 이제는 자체로 구현할 수 있더록 설계했습니다. (quackBehavior ,flybehavior)

### 하지만 왜 인터페이스를 이용해야할까요?

- "인터페이스에 맞춰서 프로그래밍한다는" 것은 "상위" 형식에 맞춰서 프로그래밍한다는 것을 의미합니다.
- 반드시 자바의 인터페이스를 사용하는 것이 아니라 실제 실행시에 쓰이는 객체가   
  코드에 의해서 고정되지 않도록, 어떤 상위 형식에 맞춰서 프로그래밍함으로써 '다형성'을 활용해야한다는 것입니다.   
  그렇게 함으로써 좀더 유연할 설계를 할 수있게 됩니다.


## 생각의 전환

1. 바뀔 수 있는 부분을 미리 예측하여 미리대처할 수 있는 유연하 설계를 해야한다.


## 결론 
1. 변화는 영역인 (소리, 날다)는 캡슐화를 통해 별도의 인터페으스로 설계 되었습니다.
2. 각각의 클래스는 연관관계 , 의존관계, 상속관계 ,구현관계로 나눌 수있습니다. 

### 스트래지 패턴
알고리즘을 정의하고 각각 캡슐화 하여 교환해서 사용할 수 있도록 만든다.   
스트래티지을 활용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.